# 缓存设计

主策略：
（Endpoint中）
Write Behind Pattern（异步缓存写入）✔️
（或者目前严格来说是缓存优先的异步写入）

## 缓存刷新机制（写缓存）

- 缓存刷新策略
  - 全量刷新
    - Directus Hook触发
      - 应用启动预热 (`init: 'app.after'`)
      - 服务器启动 (`action: 'server.start'`)
      - 定时任务 (`schedule`)
    - Directus Endpoint触发
      - API端点手动刷新
    - 自定义事件触发
      - Redis连接恢复 (`redis.on('connect')`)★
      - 数据库连接恢复 (自定义监控)
      - 外部系统事件
  - 增量刷新
    - Directus Hook触发
      - 数据库变化 (`action: '*.items.*'`)
    - Directus Endpoint触发
      - 客户端请求 (答题提交、信息更新等)
    - 自定义事件触发
      - 缓存过期 (Redis TTL events)★
      - 业务事件 (考试开始/结束等)
      - 系统状态变化 (负载、错误率等)

### 1. 全量刷新（Full Refresh）
特点： 重建整个缓存数据集
触发方式：
定时任务（如每30分钟）
应用启动初始化
手动触发的完整重建

### 2. 增量刷新（Incremental Refresh）
特点：仅更新缓存中变化的数据
触发方式：
Directus Hook触发
Directus Endpoint触发
自定义事件触发

## Redis utils设计规范

### 函数命名规范

函数名将遵循一个三段式结构：
[动词][名词(单/复数)][(From/By)来源/限定词]

#### 第一部分: 动词 (Action Verb)

这部分描述了函数要执行的操作。

*   **`set`**: 用于 **创建或更新 (upsert)** 数据。这是最常用的前缀，因为它符合 Redis 命令（如 `SET`, `HSET`）的"设置即覆盖"的特性。
*   **`get`**: 用于 **读取** 数据。
*   **`delete`**: 用于 **删除** 数据。
*   **`add`**: (较少使用) 当操作是纯粹的"添加"而不是"覆盖"时使用，例如向 List 中追加元素或向 Set 中添加成员。
*   **`exists`**: 用于检查一个键是否存在。仅返回 `true` 或 `false`，不返回具体数据。

#### 第二部分: 名词 (Noun - 单/复数是关键)

这部分描述了函数操作的核心实体或 Redis 数据结构。**通过名词的单复数形式，我们可以清晰地分辨单个操作和批量操作。**

*   **单数形式 (e.g., `Object`, `Hash`, `Key`, `List`)**:
    *   **含义**: 表示该操作作用于 **一个** 实体或 Redis 键。
    *   **示例**:
        *   `getObject(key)`: 获取并解析**一个** String 键为对象。
        *   `setHash(...)`: 将数据存入**一个** Hash 中。
        *   `getList(key)`: 获取**一个** List 的所有元素。
        *   `deleteKey(key)`: 删除**一个**键。

*   **复数形式 (e.g., `Objects`, `Hashes`, `Keys`)**:
    *   **含义**: 表示该操作作用于 **多个** 实体或 Redis 键，通常涉及循环或批量命令。
    *   **示例**:
        *   `getObjects(keys)`: 获取并解析**多个** String 键为对象数组。
        *   `setObjectsFromList(...)`: 遍历一个 **列表**，将每个成员设置为**多个**独立的 String 键。
        *   `setMultipleHashes(...)`: 创建或更新**多个** Hash。
        *   `deleteKeys(...)`: 删除**多个**键。

#### 第三部分: 来源/限定词 (Source/Qualifier - 可选后缀)

这部分是可选的，用于进一步澄清函数的行为，特别是说明数据的来源或操作的依据。

*   **`...FromObject`**: 表明操作的数据源是一个 JavaScript 对象。
*   **`...FromList`**: 表明操作的数据源是一个 JavaScript 数组（列表）。
*   **`...ByPattern`**: 表明操作是通过一个 `glob` 风格的模式（例如 `"user:*:profile"`）来选择键的。
*   **`...ByKeys`**: 表明操作是通过一个键的数组来选择目标的。

#### 第四部分: 特殊情况与综合示例

这套命名规范具有良好的扩展性，能够清晰地描述复杂的ETL（提取、转换、加载）逻辑。

##### 1. 双层嵌套缓存

*   **原函数**: `cacheNestedListToRedisHashes`
*   **行为分析**:
    *   **输入**: 获取父项列表，再为每个父项获取其子项列表，构成一个 **两级数据结构**。
    *   **输出**: 为 **每一个父项** 创建一个 **独立的 Redis Hash**，最终产生 **多个 Hash**。
*   **应用规范**: `[set]` + `[MultipleHashes]` + `[FromNestedList]`
*   **新命名**: **`setMultipleHashesFromNestedList`**
*   **解读**: 函数名清晰地表明，它会从一个 **嵌套列表** 中读取数据，然后创建/更新 **多个 Hash**。这与 `setHashFieldsFromList` (将列表存入 **单个** Hash 的多个字段) 形成了鲜明的对比，完全不会混淆。

##### 2. 嵌套对象扁平化

*   **原函数**: `setFlattenedObjectToHash`
*   **行为分析**:
    *   **输入**: 一个可能包含嵌套结构的 **单个** JavaScript 对象。
    *   **过程**: 将这个嵌套对象 **扁平化** (e.g., `{ a: { b: 1 } }` -> `{ 'a__b': '1' }`)。
    *   **输出**: 将扁平化后的数据存入 **一个 Redis Hash**。
*   **应用规范**: `[set]` + `[FlattenedHash]` + `[FromObject]`
*   **新命名**: **`setFlattenedHashFromObject`**
*   **解读**: 函数名中的 `FlattenedHash` 非常直观地描述了最终存储在 Redis 里的数据形态——一个内容经过 **扁平化处理** 的 **单个 Hash**。这与 `setHashFromObject` (如果存在的话，可能意味着只是将对象字段直接存入) 有着清晰的区别。

#### 总结

1.  **单/复数是区分单个/批量操作的基石** (`Hash` vs `MultipleHashes`)。
2.  **通过给名词添加描述性定语（如 `Flattened`）或使用明确的来源后缀（如 `FromNestedList`），可以清晰地表达函数独特的转换逻辑和数据源结构**。

### 关于更新缓存的数据来源

#### 目前的写法

目前的写法是数据获取与缓存耦合，实现方式: redisUtils.setItemsToCache(redis, namespace, fetchFunction, ...)。

这样的写法有以下问题：
- 违反单一职责原则: redisUtils 这个模块的职责应该是只处理和 Redis 相关的一切操作。一旦它包含了 fetchFunction，它就同时承担了“如何获取业务数据”的职责。这意味着您的缓存工具层现在依赖于您的数据访问层或业务逻辑。
- 可复用性差: 如果您在某个场景下已经获取到了数据，只是想把它存入缓存，您会发现这个函数用不了，因为它强制要求一个 fetchFunction。
- 测试困难: 在做单元测试时，如果您想测试缓存逻辑，您不得不去模拟（mock）那个 fetchFunction，增加了测试的复杂性。

#### 以后要改成的写法

数据获取与缓存分离。

此外，把要缓存的东西抽象到src/services文件夹里面的具体service中。